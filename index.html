<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generativus</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        /* Styles généraux */
        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #000; /* Par défaut pour le mode Gore */
            color: #fff; /* Par défaut pour le mode Gore */
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            overflow: hidden; /* Empêche le défilement */
        }

        /* Mode Amical */
        body.friendly-mode {
            background-color: #ff69b4; /* Rose vif */
            color: #fff;
        }

        /* Conteneur principal pour le jeu */
        #game-container {
            display: flex;
            flex-direction: column;
            width: 100%;
            max-width: 600px; /* Max width for larger screens */
            margin: auto;
            flex-grow: 1; /* Permet au conteneur de prendre l'espace disponible */
            padding: 10px;
            box-sizing: border-box;
        }

        /* Section des statistiques */
        #stats {
            display: flex;
            justify-content: space-around;
            padding: 5px 0;
            font-size: 0.8em;
            text-align: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2); /* Séparateur subtil */
            margin-bottom: 10px;
        }

        /* Zone de l'image - MÀJ pour 16:9 */
        #game-image-container {
            width: 100%;
            padding-bottom: 56.25%; /* Pour un ratio 16:9 (height is 9/16 of width) */
            position: relative;
            background-color: rgba(0, 0, 0, 0.5); /* Placeholder background */
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 8px; /* Coins arrondis */
            overflow: hidden;
            margin-bottom: 10px;
        }

        #game-image {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain; /* Assure que l'image s'adapte sans être coupée */
            image-rendering: pixelated; /* Pour un rendu pixel art net */
        }

        /* Indicateur de chargement pour l'image */
        #image-loading-indicator {
            position: absolute;
            color: #fff;
            font-size: 1.2em;
            display: none; /* Masqué par défaut */
        }

        /* Zone de texte principale */
        #main-text {
            flex-grow: 1; /* Prend l'espace restant */
            padding: 10px 0;
            font-size: 0.9em;
            line-height: 1.6;
            overflow-y: auto; /* Permet le défilement si le texte est trop long */
            margin-bottom: 10px;
            text-align: justify;
        }
        /* Style pour les messages du joueur dans le texte principal */
        .player-message {
            color: #88ee88; /* Couleur différente pour les messages du joueur */
            font-style: italic;
        }


        /* Zone de saisie du joueur */
        #input-area {
            width: 100%;
            display: flex;
            align-items: center;
            padding: 10px 0;
        }

        #player-input {
            flex-grow: 1;
            background-color: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: #fff;
            padding: 8px 12px;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.8em;
            border-radius: 5px;
            outline: none;
            margin-right: 10px;
        }

        #player-input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        #send-button {
            background-color: #4CAF50; /* Vert */
            border: none;
            color: white;
            padding: 8px 15px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 0.8em;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease;
            font-family: 'Press Start 2P', cursive;
        }

        #send-button:hover {
            background-color: #45a049;
        }

        /* Overlays for alerts and leaderboards */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
        }

        .overlay-content {
            background-color: #333;
            border: 2px solid #555;
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            max-width: 90%;
            max-height: 90%;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .overlay-content h2 {
            font-size: 1.5em;
            margin-bottom: 10px;
            color: #fff;
        }

        .overlay-content p {
            font-size: 1em;
            margin-bottom: 15px;
            color: #ccc;
        }

        .overlay-content button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.9em;
        }

        .overlay-content button:hover {
            background-color: #0056b3;
        }

        /* Leaderboard specific styles */
        #leaderboards-display {
            display: flex;
            flex-direction: column;
            gap: 20px;
            width: 100%;
            text-align: left; /* Align text within leaderboard sections */
        }

        .leaderboard-section {
            background-color: #222;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #444;
        }

        .leaderboard-section h3 {
            font-size: 1.2em;
            margin-bottom: 10px;
            color: #0f0; /* Green for section titles */
            text-align: center;
        }

        .leaderboard-section ol {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .leaderboard-section li {
            padding: 5px 0;
            border-bottom: 1px dashed #444;
            display: flex;
            justify-content: space-between;
            font-size: 0.9em;
        }

        .leaderboard-section li:last-child {
            border-bottom: none;
        }
        .score-value {
            font-weight: bold;
            color: #fff;
        }

        #loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 1.5em;
            z-index: 2000;
        }

        #loading-overlay p {
            margin-top: 10px;
        }

        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #fff;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Responsive adjustments */
        @media (max-width: 480px) {
            body {
                font-size: 14px;
            }
            #stats {
                font-size: 0.7em;
            }
            #player-input, #send-button {
                font-size: 0.7em;
                padding: 7px 10px;
            }
            .overlay-content h2 {
                font-size: 1.2em;
            }
            .overlay-content p {
                font-size: 0.9em;
            }
        }
    </style>
</head>
<body>
    <!-- Overlay de chargement -->
    <div id="loading-overlay" style="display: none;">
        <div class="spinner"></div>
        <p>Génération en cours...</p>
    </div>

    <div id="game-container">
        <!-- Statistiques du joueur -->
        <div id="stats">
            <span id="player-att">ATT: -</span>
            <span id="player-hp">VIE: -</span>
            <span id="player-agi">AGI: -</span>
        </div>

        <!-- Zone de l'image de jeu -->
        <div id="game-image-container">
            <img id="game-image" src="" alt="Image de jeu">
            <div id="image-loading-indicator">Chargement de l'image...</div>
        </div>

        <!-- Zone de texte principale de l'IA -->
        <div id="main-text">
            Bienvenue dans Generativus ! Un monde créé par l'IA.<br>
            Entrez votre nom et choisissez votre mode de jeu (Mode Gore ou Mode Amical) pour commencer.
        </div>

        <!-- Zone de saisie du joueur -->
        <div id="input-area">
            <input type="text" id="player-input" placeholder="Votre action ici...">
            <button id="send-button">Envoyer</button>
        </div>
    </div>

    <!-- Modale personnalisée pour les messages et les classements -->
    <div id="custom-modal" class="overlay" style="display: none;">
        <div class="overlay-content">
            <h2 id="modal-title"></h2>
            <p id="modal-message"></p>
            <div id="leaderboards-display" style="display: none;">
                <!-- Les classements seront injectés ici -->
            </div>
            <button id="modal-close-button">Fermer</button>
        </div>
    </div>

    <script type="module">
        // Importations Firebase
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, collection, query, limit, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Variables globales Firebase (injectées par l'environnement Canvas)
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // Configuration de l'API Gemini
        // IMPORTANT : Ces clés API sont des placeholders. En production, elles doivent être sécurisées.
        const GEMINI_TEXT_API_KEY = ""; // Laisser vide pour que Canvas l'injecte
        const GEMINI_IMAGE_API_KEY = ""; // Laisser vide pour que Canvas l'injecte

        // Variables globales du jeu
        let player = {
            name: '',
            att: 5, // Attaque
            vie: 20, // Points de vie actuels
            maxVie: 20, // Points de vie maximum
            agi: 1, // Agilité
            inventory: [], // Géré textuellement par l'IA, mais on peut garder une trace simple pour l'IA
            score: 0,
            mode: '' // 'Gore' ou 'Amical'
        };

        let gameDifficulty = 0; // Pourcentage de 0 à 25
        let gameStarted = false;
        let authReady = false;
        let db, auth, userId;

        // Références aux éléments du DOM
        const gameContainer = document.getElementById('game-container');
        const statsDisplay = document.getElementById('stats');
        const playerAttSpan = document.getElementById('player-att');
        const playerHpSpan = document.getElementById('player-hp');
        const playerAgiSpan = document.getElementById('player-agi');
        const gameImage = document.getElementById('game-image');
        const imageLoadingIndicator = document.getElementById('image-loading-indicator');
        const mainTextDiv = document.getElementById('main-text');
        const playerInput = document.getElementById('player-input');
        const sendButton = document.getElementById('send-button');
        const loadingOverlay = document.getElementById('loading-overlay');
        const customModal = document.getElementById('custom-modal');
        const modalTitle = document.getElementById('modal-title');
        const modalMessage = document.getElementById('modal-message');
        const leaderboardsDisplay = document.getElementById('leaderboards-display');
        const modalCloseButton = document.getElementById('modal-close-button');

        let chatHistory = []; // Historique pour l'API Gemini (texte)

        /**
         * Affiche ou masque l'overlay de chargement.
         * @param {boolean} show - True pour afficher, false pour masquer.
         * @param {string} message - Message à afficher pendant le chargement.
         */
        function showLoading(show, message = "Génération en cours...") {
            loadingOverlay.style.display = show ? 'flex' : 'none';
            loadingOverlay.querySelector('p').textContent = message;
        }

        /**
         * Affiche une modale personnalisée.
         * @param {string} title - Titre de la modale.
         * @param {string} message - Message de la modale.
         * @param {boolean} showLeaderboards - Indique si les classements doivent être affichés.
         */
        async function showCustomModal(title, message, showLeaderboards = false) {
            modalTitle.textContent = title;
            modalMessage.textContent = message;
            if (showLeaderboards) {
                await displayLeaderboards();
                leaderboardsDisplay.style.display = 'flex';
            } else {
                leaderboardsDisplay.style.display = 'none';
            }
            customModal.style.display = 'flex';
        }

        // Fermer la modale
        modalCloseButton.onclick = () => {
            customModal.style.display = 'none';
            if (player.vie <= 0) { // Si le joueur est mort, revenir au menu principal
                resetGame();
                showMainMenu();
            }
        };

        /**
         * Initialise Firebase et l'authentification.
         */
        async function initializeFirebase() {
            try {
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        userId = user.uid;
                        console.log("Firebase Authenticated. User ID:", userId);
                    } else {
                        console.log("Firebase Not Authenticated, attempting anonymous sign-in.");
                        try {
                            if (initialAuthToken) {
                                await signInWithCustomToken(auth, initialAuthToken);
                                userId = auth.currentUser.uid;
                                console.log("Signed in with custom token. User ID:", userId);
                            } else {
                                await signInAnonymously(auth);
                                userId = auth.currentUser.uid;
                                console.log("Signed in anonymously. User ID:", userId);
                            }
                        } catch (error) {
                            console.error("Firebase Auth Error:", error);
                            showCustomModal("Erreur d'authentification", "Impossible de se connecter à Firebase. Certaines fonctionnalités pourraient être limitées.");
                            userId = crypto.randomUUID(); // Fallback for userId
                            console.warn("Using a random UUID for userId as fallback:", userId);
                        }
                    }
                    authReady = true;
                    if (!gameStarted) {
                        showMainMenu(); // Afficher le menu principal une fois que l'authentification est prête
                    }
                });
            } catch (error) {
                console.error("Erreur lors de l'initialisation de Firebase:", error);
                showCustomModal("Erreur Firebase", "Impossible d'initialiser Firebase. Vérifiez la configuration.");
                userId = crypto.randomUUID(); // Fallback for userId
                console.warn("Using a random UUID for userId as fallback:", userId);
                authReady = true; // Permettre au jeu de continuer même si Firebase a échoué
                if (!gameStarted) {
                    showMainMenu();
                }
            }
        }

        /**
         * Met à jour l'affichage des statistiques du joueur.
         */
        function updateStatsUI() {
            playerAttSpan.textContent = `ATT: ${player.att}`;
            playerHpSpan.textContent = `VIE: ${Math.max(0, player.vie)}/${player.maxVie}`;
            playerAgiSpan.textContent = `AGI: ${player.agi}`;
        }

        /**
         * Met à jour le texte principal affiché dans le jeu.
         * @param {string} text - Le texte à afficher.
         * @param {boolean} isPlayerMessage - Indique si le message vient du joueur.
         */
        function updateMainText(text, isPlayerMessage = false) {
            const p = document.createElement('p');
            p.innerHTML = text; // Utiliser innerHTML pour permettre les retours à la ligne de l'IA
            if (isPlayerMessage) {
                p.classList.add('player-message');
            }
            mainTextDiv.appendChild(p);
            mainTextDiv.scrollTop = mainTextDiv.scrollHeight; // Défilement automatique vers le bas
        }

        /**
         * Met à jour l'image du jeu en appelant l'API Gemini Image.
         * @param {string} imagePrompt - Le prompt pour la génération d'image.
         */
        async function updateGameImage(imagePrompt) {
            gameImage.style.opacity = 0; // Masque l'image précédente
            imageLoadingIndicator.style.display = 'block'; // Affiche l'indicateur
            gameImage.src = ''; // Efface l'image précédente

            try {
                // Pour imagen-3.0-generate-002, la clé API est passée dans l'URL.
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-002:predict?key=${GEMINI_IMAGE_API_KEY}`;
                const payload = {
                    instances: {
                        // MÀJ du prompt pour le ratio 16:9
                        prompt: `${imagePrompt}, pixel art 16:9, ${player.mode === 'Gore' ? 'black and white, dark, grim, scary' : 'vivid colors, cute, friendly, bright'}`
                    },
                    parameters: {
                        sampleCount: 1
                    }
                };

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const result = await response.json();

                if (result.predictions && result.predictions.length > 0 && result.predictions[0].bytesBase64Encoded) {
                    const imageUrl = `data:image/png;base64,${result.predictions[0].bytesBase64Encoded}`;
                    gameImage.src = imageUrl;
                    gameImage.onload = () => {
                        imageLoadingIndicator.style.display = 'none';
                        gameImage.style.opacity = 1; // Révèle la nouvelle image
                    };
                    gameImage.onerror = () => {
                        console.error("Erreur de chargement de l'image. Tentative de placeholder.");
                        // MÀJ du placeholder pour le ratio 16:9
                        gameImage.src = `https://placehold.co/400x225/808080/FFFFFF?text=Image+Non+Disponible`;
                        imageLoadingIndicator.style.display = 'none';
                        gameImage.style.opacity = 1;
                    };
                } else {
                    console.error("Réponse de l'API Image inattendue:", result);
                    // MÀJ du placeholder pour le ratio 16:9
                    gameImage.src = `https://placehold.co/400x225/808080/FFFFFF?text=Image+Non+Disponible`;
                    imageLoadingIndicator.style.display = 'none';
                    gameImage.style.opacity = 1;
                }
            } catch (error) {
                console.error("Erreur lors de la génération d'image:", error);
                // MÀJ du placeholder pour le ratio 16:9
                gameImage.src = `https://placehold.co/400x225/808080/FFFFFF?text=Erreur+Image`;
                imageLoadingIndicator.style.display = 'none';
                gameImage.style.opacity = 1;
            }
        }

        /**
         * Affiche le menu principal et gère la saisie initiale.
         */
        async function showMainMenu() {
            gameStarted = false;
            mainTextDiv.innerHTML = 'Bienvenue dans Generativus ! Un monde créé par l\'IA.<br>Entrez votre nom et choisissez votre mode de jeu (Mode Gore ou Mode Amical) pour commencer.';
            updateStatsUI(); // Réinitialise les stats affichées
            playerInput.placeholder = "Votre nom et mode (Ex: Arthur Mode Gore)";
            // Afficher l'image du menu principal
            await updateGameImage("pixel art 16:9, gloomy dungeon, Castlevania style, main menu, title Generativus");
            sendButton.onclick = handleMainMenuInput; // Attacher le gestionnaire pour le menu
            playerInput.onkeypress = (e) => {
                if (e.key === 'Enter') handleMainMenuInput();
            };
        }

        /**
         * Gère la saisie du joueur dans le menu principal.
         */
        async function handleMainMenuInput() {
            const input = playerInput.value.trim();
            if (!input) return;

            updateMainText(`> ${input}`, true); // Affiche la saisie du joueur
            playerInput.value = ''; // Efface la saisie

            const nameMatch = input.match(/^(.*?)\s+(Mode\s+(Gore|Amical))$/i);
            if (nameMatch) {
                player.name = nameMatch[1].trim();
                player.mode = nameMatch[3].trim();
                if (player.name && player.mode) {
                    startGame();
                } else {
                    updateMainText("Format invalide. Veuillez entrer votre nom suivi de 'Mode Gore' ou 'Mode Amical'. Ex: 'Arthur Mode Gore'");
                }
            } else {
                updateMainText("Format invalide. Veuillez entrer votre nom suivi de 'Mode Gore' ou 'Mode Amical'. Ex: 'Arthur Mode Gore'");
            }
        }

        /**
         * Démarre une nouvelle partie.
         */
        async function startGame() {
            gameStarted = true;
            player.vie = player.maxVie; // Réinitialise la vie
            player.score = 0;
            gameDifficulty = 0; // Difficultité initiale
            updateStatsUI();
            document.body.classList.toggle('friendly-mode', player.mode === 'Amical');
            mainTextDiv.innerHTML = ''; // Efface le texte du menu
            playerInput.placeholder = "Votre action...";
            sendButton.onclick = sendPlayerAction; // Attacher le gestionnaire pour le jeu
            playerInput.onkeypress = (e) => {
                if (e.key === 'Enter') sendPlayerAction();
            };

            await generateBackstory();
        }

        /**
         * Génère la backstory du personnage via l'API Gemini Text.
         */
        async function generateBackstory() {
            showLoading(true, "Génération de votre histoire...");
            // MÀJ du prompt pour la perspective de l'avatar
            const prompt = `Génère une brève backstory pour vous, un personnage nommé ${player.name}, qui êtes sur le point d'entrer dans un donjon appelé Generativus. Le mode de jeu est "${player.mode}". Le ton doit correspondre au mode. Sois très concis, juste un court paragraphe.`;

            chatHistory = [{ role: "user", parts: [{ text: prompt }] }];

            try {
                const response = await callGeminiTextAPI(chatHistory);
                updateMainText(response);
                chatHistory.push({ role: "model", parts: [{ text: response }] });
                await continueGame();
            } catch (error) {
                console.error("Erreur lors de la génération de la backstory:", error);
                updateMainText("Une erreur est survenue lors de la génération de l'histoire. Veuillez réessayer.");
                showLoading(false);
            }
        }

        /**
         * Continue le jeu en générant le prochain événement.
         */
        async function continueGame() {
            // Déterminer la prochaine action de l'IA (événement, combat, etc.)
            // Ceci sera géré principalement par l'IA textuelle
            showLoading(true, "Exploration du donjon...");
            // MÀJ du prompt pour la perspective de l'avatar
            const prompt = `Vous (${player.name}, ATT:${player.att}, VIE:${player.vie}/${player.maxVie}, AGI:${player.agi}) êtes dans un donjon. Votre inventaire (non-visible) contient : ${player.inventory.length > 0 ? player.inventory.join(', ') : 'rien'}. La difficulté actuelle du jeu est de ${gameDifficulty}%.
            Quel événement se produit ? Décrivez-le brièvement, et proposez des choix ou attendez une action libre de votre part. Le ton est "${player.mode}".
            **Format de réponse attendu (JSON):**
            \`\`\`json
            {
              "narrative_text": "Texte décrivant l'événement et les options.",
              "image_prompt": "Prompt pour l'image (pixel art 16:9, [contexte], [mode])",
              "action_required": true
            }
            \`\`\`
            `;

            chatHistory.push({ role: "user", parts: [{ text: prompt }] });

            try {
                const responseJson = await callGeminiTextAPI(chatHistory, {
                    responseMimeType: "application/json",
                    responseSchema: {
                        type: "OBJECT",
                        properties: {
                            "narrative_text": { "type": "STRING" },
                            "image_prompt": { "type": "STRING" },
                            "action_required": { "type": "BOOLEAN" }
                        },
                        "propertyOrdering": ["narrative_text", "image_prompt", "action_required"]
                    }
                });

                const parsedResponse = JSON.parse(responseJson);
                updateMainText(parsedResponse.narrative_text);
                chatHistory.push({ role: "model", parts: [{ text: responseJson }] }); // Stocke la réponse JSON de l'IA

                if (parsedResponse.image_prompt) {
                    await updateGameImage(parsedResponse.image_prompt);
                }
                player.score++; // Chaque événement survécu augmente le score
            } catch (error) {
                console.error("Erreur lors de la continuation du jeu:", error);
                updateMainText("Une erreur est survenue, le donjon semble instable. Veuillez réessayer.");
            } finally {
                showLoading(false);
            }
        }

        /**
         * Gère l'envoi de l'action du joueur à l'API Gemini Text.
         */
        async function sendPlayerAction() {
            const input = playerInput.value.trim();
            if (!input) return;

            updateMainText(`> ${input}`, true); // Affiche la saisie du joueur
            playerInput.value = ''; // Efface la saisie

            showLoading(true, "L'IA analyse votre action...");

            // MÀJ du prompt pour la perspective de l'avatar
            const prompt = `Vous (${player.name}, ATT:${player.att}, VIE:${player.vie}/${player.maxVie}, AGI:${player.agi}) avez effectué l'action: "${input}". Votre inventaire (non-visible) contient : ${player.inventory.length > 0 ? player.inventory.join(', ') : 'rien'}. La difficulté actuelle du jeu est de ${gameDifficulty}%.
            Évaluez la réussite/échec de cette action en fonction du contexte précédent, du réalisme, et de la difficulté. Décrivez les conséquences (dégâts, gain de vie, obtention/perte d'objets, changement de statistiques, fuite, fin de combat, etc.).
            Si vous demandez votre inventaire, décrivez-le. Si vous utilisez un objet, gérez son effet. Si vous tentez d'équiper, appliquez les stats.
            Augmentez la difficulté du jeu (gameDifficulty) très légèrement après chaque action réussie qui fait progresser l'histoire (max 25%).
            **Format de réponse attendu (JSON):**
            \`\`\`json
            {
              "narrative_text": "Texte décrivant les conséquences de l'action.",
              "image_prompt": "Prompt pour l'image (pixel art 16:9, [contexte], [mode])",
              "stat_changes": { "att": 0, "vie": 0, "maxVie": 0, "agi": 0 },
              "inventory_changes": [], // Ex: [{ "action": "add", "item": "épée rouillée" }, { "action": "remove", "item": "potion de soin" }]
              "game_over": false,
              "next_event_ready": false // True si l'IA a terminé sa réponse pour cet événement et attend le prochain
            }
            \`\`\`
            Note: Si vous utilisez une potion de soin, la vie ne peut pas dépasser la vie maximale. Si un objet est équipé, ses stats sont ajoutées à vos stats et supprimées de l'inventaire virtuel, et les stats de l'objet précédemment équipé (si applicable) sont retirées. La vie maximum ne doit jamais dépasser 99.
            `;

            chatHistory.push({ role: "user", parts: [{ text: prompt }] });

            try {
                const responseJson = await callGeminiTextAPI(chatHistory, {
                    responseMimeType: "application/json",
                    responseSchema: {
                        type: "OBJECT",
                        properties: {
                            "narrative_text": { "type": "STRING" },
                            "image_prompt": { "type": "STRING" },
                            "stat_changes": {
                                "type": "OBJECT",
                                "properties": {
                                    "att": { "type": "NUMBER" },
                                    "vie": { "type": "NUMBER" },
                                    "maxVie": { "type": "NUMBER" },
                                    "agi": { "type": "NUMBER" }
                                }
                            },
                            "inventory_changes": {
                                "type": "ARRAY",
                                "items": {
                                    "type": "OBJECT",
                                    "properties": {
                                        "action": { "type": "STRING" },
                                        "item": { "type": "STRING" }
                                    }
                                }
                            },
                            "game_over": { "type": "BOOLEAN" },
                            "next_event_ready": { "type": "BOOLEAN" }
                        },
                        "propertyOrdering": ["narrative_text", "image_prompt", "stat_changes", "inventory_changes", "game_over", "next_event_ready"]
                    }
                });

                const parsedResponse = JSON.parse(responseJson);

                updateMainText(parsedResponse.narrative_text);
                chatHistory.push({ role: "model", parts: [{ text: responseJson }] }); // Stocke la réponse JSON de l'IA

                // Appliquer les changements de stats
                if (parsedResponse.stat_changes) {
                    player.att += parsedResponse.stat_changes.att || 0;
                    player.vie += parsedResponse.stat_changes.vie || 0;
                    player.maxVie += parsedResponse.stat_changes.maxVie || 0;
                    player.agi += parsedResponse.stat_changes.agi || 0;

                    // Clamp VIE à maxVie et maxVie à 99
                    player.vie = Math.min(player.vie, player.maxVie);
                    player.maxVie = Math.min(player.maxVie, 99);
                    player.vie = Math.max(0, player.vie); // Empêche la vie négative d'être affichée si pas game over

                    updateStatsUI();
                }

                // Gérer l'inventaire (pour la trace locale, l'IA est la source de vérité)
                if (parsedResponse.inventory_changes && Array.isArray(parsedResponse.inventory_changes)) {
                    parsedResponse.inventory_changes.forEach(change => {
                        if (change.action === "add") {
                            player.inventory.push(change.item);
                        } else if (change.action === "remove") {
                            const index = player.inventory.indexOf(change.item);
                            if (index > -1) {
                                player.inventory.splice(index, 1);
                            }
                        }
                    });
                }

                // Augmenter la difficulté si l'événement progresse
                if (parsedResponse.next_event_ready && gameDifficulty < 25) {
                    gameDifficulty = Math.min(25, gameDifficulty + 0.5); // Augmentation légère
                }

                if (parsedResponse.image_prompt) {
                    await updateGameImage(parsedResponse.image_prompt);
                }

                if (parsedResponse.game_over || player.vie <= 0) {
                    player.vie = 0; // Assurer que la vie est à 0 à la fin
                    updateStatsUI();
                    await gameOver();
                } else if (parsedResponse.next_event_ready) {
                    player.score++; // Augmenter le score pour chaque événement/combat terminé
                    await continueGame(); // Passer au prochain événement
                }
            } catch (error) {
                console.error("Erreur lors du traitement de l'action du joueur:", error);
                updateMainText("Une erreur est survenue lors de l'analyse de votre action. Le jeu est bloqué, veuillez actualiser la page.");
                showLoading(false);
            } finally {
                showLoading(false);
            }
        }

        /**
         * Appelle l'API Gemini Text.
         * @param {Array} history - L'historique des messages pour l'API.
         * @param {Object} generationConfig - Configuration de génération pour la réponse structurée (optionnel).
         * @returns {Promise<string>} La réponse textuelle ou JSON de l'IA.
         */
        async function callGeminiTextAPI(history, generationConfig = {}) {
            const payload = { contents: history, generationConfig: generationConfig };
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${GEMINI_TEXT_API_KEY}`;

            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            const result = await response.json();

            if (result.candidates && result.candidates.length > 0 &&
                result.candidates[0].content && result.candidates[0].content.parts &&
                result.candidates[0].content.parts.length > 0) {
                return result.candidates[0].content.parts[0].text;
            } else {
                console.error("Réponse de l'API Gemini inattendue:", result);
                throw new Error("Impossible d'obtenir une réponse de l'IA. Vérifiez la console pour plus de détails.");
            }
        }

        /**
         * Gère la fin de partie (mort du joueur).
         */
        async function gameOver() {
            showLoading(true, "Fin de partie...");
            let message = `Votre aventure dans Generativus prend fin. Vous avez survécu à ${player.score} événements.`;
            modalTitle.textContent = "FIN DE PARTIE !";
            modalMessage.textContent = message;

            await saveScore(player.name, player.score, player.mode);
            await showCustomModal("FIN DE PARTIE !", message, true); // Afficher les classements
            showLoading(false);
        }

        /**
         * Réinitialise l'état du jeu.
         */
        function resetGame() {
            player = {
                name: '',
                att: 5,
                vie: 20,
                maxVie: 20,
                agi: 1,
                inventory: [],
                score: 0,
                mode: ''
            };
            gameDifficulty = 0;
            gameStarted = false;
            chatHistory = [];
            document.body.classList.remove('friendly-mode');
            mainTextDiv.innerHTML = ''; // Nettoyer le texte
            gameImage.src = ''; // Nettoyer l'image
            playerInput.value = '';
            playerInput.placeholder = "Votre nom et mode (Ex: Arthur Mode Gore)";
            updateStatsUI();
        }

        /**
         * Enregistre le score du joueur dans Firestore si c'est un top 5.
         * @param {string} name - Nom du joueur.
         * @param {number} score - Score du joueur.
         * @param {string} mode - Mode de jeu ('Gore' ou 'Amical').
         */
        async function saveScore(name, score, mode) {
            if (!authReady || !db || !userId) {
                console.warn("Firestore non prêt, score non enregistré.");
                return;
            }
            try {
                const leaderboardDocRef = doc(db, `artifacts/${appId}/public/data/leaderboards`, mode.toLowerCase());
                const leaderboardSnap = await getDoc(leaderboardDocRef);

                let scores = [];
                if (leaderboardSnap.exists()) {
                    scores = leaderboardSnap.data().topScores || [];
                }

                scores.push({ name: name, score: score, timestamp: Date.now(), userId: userId });

                // Trier et garder seulement les 5 meilleurs scores
                scores.sort((a, b) => b.score - a.score);
                scores = scores.slice(0, 5);

                await setDoc(leaderboardDocRef, { topScores: scores });
                console.log("Score enregistré avec succès !");
            } catch (error) {
                console.error("Erreur lors de l'enregistrement du score:", error);
                showCustomModal("Erreur de sauvegarde", "Impossible d'enregistrer votre score dans le classement.");
            }
        }

        /**
         * Affiche les classements depuis Firestore.
         */
        async function displayLeaderboards() {
            if (!authReady || !db || !userId) {
                console.warn("Firestore non prêt, impossible d'afficher les classements.");
                leaderboardsDisplay.innerHTML = '<p>Classements non disponibles.</p>';
                return;
            }

            leaderboardsDisplay.innerHTML = ''; // Nettoyer l'affichage précédent
            showLoading(true, "Chargement des classements...");

            const modes = ['gore', 'amical'];
            for (const mode of modes) {
                try {
                    const leaderboardDocRef = doc(db, `artifacts/${appId}/public/data/leaderboards`, mode);
                    const leaderboardSnap = await getDoc(leaderboardDocRef);

                    let scores = [];
                    if (leaderboardSnap.exists()) {
                        scores = leaderboardSnap.data().topScores || [];
                    }

                    const section = document.createElement('div');
                    section.classList.add('leaderboard-section');
                    section.innerHTML = `<h3>Mode ${mode.charAt(0).toUpperCase() + mode.slice(1)}</h3><ol></ol>`;
                    const ol = section.querySelector('ol');

                    if (scores.length === 0) {
                        ol.innerHTML = '<li>Aucun score enregistré.</li>';
                    } else {
                        scores.forEach((s, index) => {
                            const li = document.createElement('li');
                            li.innerHTML = `<span>${index + 1}. ${s.name}</span> <span class="score-value">${s.score}</span>`;
                            ol.appendChild(li);
                        });
                    }
                    leaderboardsDisplay.appendChild(section);

                } catch (error) {
                    console.error(`Erreur lors du chargement du classement ${mode}:`, error);
                    const section = document.createElement('div');
                    section.classList.add('leaderboard-section');
                    section.innerHTML = `<h3>Mode ${mode.charAt(0).toUpperCase() + mode.slice(1)}</h3><p>Erreur de chargement.</p>`;
                    leaderboardsDisplay.appendChild(section);
                }
            }
            showLoading(false);
        }

        // Initialisation à l'ouverture de la page
        window.onload = initializeFirebase;
    </script>
</body>
</html>
