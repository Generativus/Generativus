<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generativus</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        /* Styles généraux */
        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #000; /* Toujours noir pour le mode Gore */
            color: #fff; /* Toujours blanc pour le mode Gore */
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            overflow: hidden; /* Empêche le défilement du corps */
        }

        /* Mode Amical (styles retirés car mode supprimé) */
        /* body.friendly-mode { ... } */

        /* Conteneur principal pour le jeu */
        #game-container {
            display: flex;
            flex-direction: column;
            width: 100%;
            max-width: 600px; /* Max width for larger screens */
            margin: auto;
            flex-grow: 1; /* Permet au conteneur de prendre l'espace disponible */
            padding: 10px;
            box-sizing: border-box;
            height: 100vh; /* S'assure que le conteneur prend toute la hauteur disponible */
        }

        /* Section des statistiques du joueur (fixe en haut) */
        #stats {
            display: flex;
            justify-content: space-around;
            padding: 5px 0;
            font-size: 0.8em;
            text-align: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2); /* Séparateur subtil */
            margin-bottom: 10px;
        }

        /* Zone de l'image (fixe après les stats joueur) */
        #game-image-container {
            width: 100%;
            padding-bottom: 56.25%; /* Pour un ratio 16:9 (height is 9/16 of width) */
            position: relative;
            background-color: rgba(0, 0, 0, 0.5); /* Placeholder background */
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 8px; /* Coins arrondis */
            overflow: hidden;
            margin-bottom: 10px;
        }

        #game-image {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain; /* Assure que l'image s'adapte sans être coupée */
            image-rendering: pixelated; /* Pour un rendu pixel art net */
            display: none; /* Cache l'image par défaut au chargement */
        }

        /* Indicateur de chargement global, maintenant localisé à l'image */
        #loading-overlay {
            position: absolute; /* Positionnement par rapport au parent #game-image-container */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000; /* Fond noir complètement opaque */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 1.5em;
            z-index: 100; /* Plus haut que l'image pour la couvrir */
            opacity: 0; /* Commence transparent, contrôlé par JS */
            transition: opacity 0.3s ease-out; /* Transition pour une disparition douce */
            pointer-events: none; /* Permet le clic à travers quand invisible */
        }

        #loading-overlay.active {
            opacity: 1;
            pointer-events: auto; /* Bloque le clic quand visible */
        }

        #loading-overlay p {
            margin-top: 10px;
        }

        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #fff;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Section des statistiques de l'ennemi (fixe sous l'image - sera masquée) */
        #enemy-stats {
            display: none; /* Toujours masqué */
        }
        /* Les styles d'enfants comme #enemy-name, #enemy-att, etc., ne sont plus nécessaires s'ils sont masqués */

        /* Nouveau conteneur pour le contenu défilable (texte principal seulement) */
        #scrollable-content {
            flex-grow: 1; /* Prend tout l'espace vertical disponible */
            overflow-y: auto; /* Permet le défilement vertical */
            padding-right: 5px; /* Pour éviter que la scrollbar ne masque le contenu */
            -ms-overflow-style: none;  /* IE and Edge */
            scrollbar-width: none;  /* Firefox */
        }
        #scrollable-content::-webkit-scrollbar { /* Chrome, Safari, Opera */
            display: none;
        }

        /* Zone de texte principale */
        #main-text {
            padding: 10px 0;
            font-size: 0.9em;
            line-height: 1.6;
            margin-bottom: 10px;
            text-align: justify;
        }
        /* Style pour les messages du joueur dans le texte principal */
        .player-message {
            color: #88ee88; /* Couleur différente pour les messages du joueur */
            font-style: italic;
        }


        /* Zone de saisie du joueur (fixe en bas) */
        #input-area {
            width: 100%;
            display: flex;
            align-items: center;
            padding: 10px 0;
        }

        #player-input {
            flex-grow: 1;
            background-color: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: #fff;
            padding: 8px 12px;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.8em;
            border-radius: 5px;
            outline: none;
            margin-right: 10px;
        }

        #player-input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        #send-button {
            background-color: #4CAF50; /* Vert */
            border: none;
            color: white;
            padding: 8px 15px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 0.8em;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease;
            font-family: 'Press Start 2P', cursive;
        }

        #send-button:hover {
            background-color: #45a049;
        }

        /* Nouveau style pour le bouton "Terminer la partie" */
        #end-game-button {
            background-color: #CC0000; /* Rouge foncé pour l'horreur */
            border: none;
            color: white;
            padding: 10px 20px;
            text-align: center;
            text-decoration: none;
            display: block; /* Prend toute la largeur disponible */
            width: 100%;
            font-size: 1em;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.1s ease;
            font-family: 'Press Start 2P', cursive;
            margin-top: 15px; /* Espace au-dessus du bouton */
            box-shadow: 0 5px #990000; /* Ombre pour un effet 3D */
            position: relative;
            top: 0;
            left: 0;
        }

        #end-game-button:hover {
            background-color: #AA0000; /* Rouge plus foncé au survol */
        }

        #end-game-button:active {
            box-shadow: 0 2px #770000; /* Ombre plus petite au clic */
            transform: translateY(3px); /* Effet de pression */
        }

        /* Overlays for alerts and leaderboards */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
        }

        /* Refonte du style de la modale pour le classement */
        .overlay-content {
            background-color: transparent; /* Pas de fond */
            border: none; /* Pas de bordure */
            border-radius: 0; /* Pas de coins arrondis */
            padding: 20px;
            text-align: center;
            max-width: 90%;
            max-height: 90%;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 15px;
            color: inherit; /* Hérite de la couleur du corps */
        }

        .overlay-content h2 {
            font-size: 1.5em;
            margin-bottom: 10px;
            color: inherit; /* Hérite de la couleur du corps */
        }

        .overlay-content p {
            font-size: 1em;
            margin-bottom: 15px;
            color: inherit; /* Hérite de la couleur du corps */
        }

        .overlay-content button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.9em;
        }

        .overlay-content button:hover {
            background-color: #0056b3;
        }

        /* Leaderboard specific styles */
        #leaderboards-display {
            display: flex;
            flex-direction: column;
            gap: 20px;
            width: 100%;
            text-align: left; /* Align text within leaderboard sections */
            color: inherit; /* Hérite de la couleur du corps */
        }

        .leaderboard-section {
            background-color: transparent; /* Pas de fond */
            padding: 0; /* Pas de padding spécifique */
            border-radius: 0; /* Pas de coins arrondis */
            border: none; /* Pas de bordure */
        }

        .leaderboard-section h3 {
            font-size: 1.2em;
            margin-top: 15px;
            margin-bottom: 5px;
            color: inherit; /* Hérite de la couleur du corps */
            text-align: center;
        }

        .leaderboard-section ol {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .leaderboard-section li {
            padding: 5px 0;
            border-bottom: 1px dashed rgba(255, 255, 255, 0.2); /* Ligne de séparation subtile */
            display: flex;
            justify-content: space-between;
            font-size: 0.9em;
        }

        .leaderboard-section li:last-child {
            border-bottom: none;
        }
        .score-value {
            font-weight: bold;
            color: inherit; /* Hérite de la couleur du corps */
        }

        /* Responsive adjustments */
        @media (max-width: 480px) {
            body {
                font-size: 14px;
            }
            #stats {
                font-size: 0.7em;
            }
            #player-input, #send-button, #end-game-button { /* Inclure le nouveau bouton */
                font-size: 0.7em;
                padding: 7px 10px;
            }
            .overlay-content h2 {
                font-size: 1.2em;
            }
            .overlay-content p {
                font-size: 0.9em;
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <!-- Statistiques du joueur -->
        <div id="stats">
            <span id="player-att">ATT: -</span>
            <span id="player-hp">VIE: -</span>
            <span id="player-agi">AGI: -</span>
        </div>

        <!-- Zone de l'image (fixe) -->
        <div id="game-image-container">
            <img id="game-image" src="" alt="Image de jeu">
            <!-- Overlay de chargement déplacé ici -->
            <div id="loading-overlay" style="display: none;">
                <div class="spinner"></div>
                <p id="loading-message">Interprétation...</p>
            </div>
        </div>

        <!-- Section des statistiques de l'ennemi (masquée - reste dans le DOM mais cachée par display:none) -->
        <div id="enemy-stats">
            <!-- Contenu des stats ennemies sera vide ou non mis à jour -->
        </div>

        <!-- Nouveau conteneur pour le contenu défilable (texte principal seulement) -->
        <div id="scrollable-content">
            <!-- Zone de texte principale -->
            <div id="main-text">
                Bienvenue dans Generativus ! Un monde généré de manière dynamique.<br>
                Entrez votre nom pour commencer.
            </div>
        </div>

        <!-- Zone de saisie du joueur (fixe en bas) -->
        <div id="input-area">
            <input type="text" id="player-input" placeholder="Ex: Gérard">
            <button id="send-button">Envoyer</button>
        </div>
        <!-- Conteneur pour le bouton "Terminer la partie" -->
        <div id="game-over-action-area" style="display: none;">
            <button id="end-game-button">Terminer la partie</button>
        </div>
    </div>

    <!-- Modale personnalisée pour les messages et les classements -->
    <div id="custom-modal" class="overlay" style="display: none;">
        <div class="overlay-content">
            <h2 id="modal-title"></h2>
            <p id="modal-message"></p>
            <div id="leaderboards-display" style="display: none;">
                <!-- Les classements seront injectés ici -->
            </div>
            <button id="modal-close-button">Recommencer</button>
        </div>
    </div>

    <script type="module">
        // Importations Firebase
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, collection, query, limit, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // ==============================================================================
        // CONFIGURATION FIREBASE POUR DÉPLOIEMENT HORS CANVAS (ex: GitHub Pages)
        // L'ID de l'application Firestore pour les classements. DOIT ÊTRE UNIQUE ET FIXE
        // pour que tous les joueurs se connectent au même classement global.
        // ==============================================================================
        const appId = 'generativus-global-leaderboard'; // ID fixe pour le classement global
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {
            apiKey: "AIzaSyDuEm2htptr7pY_EnFoEJPmUOYhKzYC9pE",
            authDomain: "generativus-b65cb.firebaseapp.com",
            projectId: "generativus-b65cb",
            storageBucket: "generativus-b65cb.firebasestorage.app",
            appId: "1:853953342399:web:433b07d4396a136a60cf0a",
            messagingSenderId: "853953342399",
            measurementId: "G-KE0ZEXWBPR"
        };
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // ==============================================================================
        // CONFIGURATION DES CLÉS API GEMINI
        // Ces clés sont utilisées pour les appels aux modèles Gemini.
        // Elles ont été restaurées à partir de votre fichier d'origine.
        // ==============================================================================
        const GEMINI_TEXT_API_KEY = "AIzaSyBBRm5QNpoiz4UeFLN-ARuGDFpXjhTeWP0"; // Renseignée à partir de votre fichier d'origine
        const GEMINI_IMAGE_API_KEY = "AIzaSyA1lOo6sFFDhy2jtzWJgh33rcVoTDQ07C4"; // Renseignée à partir de votre fichier d'origine


        // Variables globales du jeu
        let player = {
            name: '',
            att: 5, // Attaque
            vie: 20, // Points de vie actuels
            maxVie: 20, // Points de vie maximum
            agi: 1, // Agilité
            inventory: [], // Géré textuellement par l'IA, mais on peut garder une trace simple pour l'IA
            score: 0,
            mode: 'Gore' // Mode Amical supprimé, toujours en Gore
        };
        // currentEnemy n'est plus nécessaire car les stats ne sont plus affichées
        // let currentEnemy = null;

        const MAX_DIFFICULTY = 25; // Constante pour la difficulté maximale
        let gameDifficulty = 1; // DIFFICULTÉ INITIALE À 1
        let gameStarted = false;
        let authReady = false;
        let db, auth, userId;
        let lastPlayerMessageElement = null; // Nouvelle variable pour la référence à l'élément du message du joueur

        // Références aux éléments du DOM
        const gameContainer = document.getElementById('game-container');
        const statsDisplay = document.getElementById('stats');
        const playerAttSpan = document.getElementById('player-att');
        const playerHpSpan = document.getElementById('player-hp');
        const playerAgiSpan = document.getElementById('player-agi');
        const scrollableContent = document.getElementById('scrollable-content'); // Maintenu pour le texte
        const gameImage = document.getElementById('game-image');
        const loadingOverlay = document.getElementById('loading-overlay'); // Référence à l'overlay principal
        const loadingMessage = document.getElementById('loading-message'); // Référence au texte de l'overlay

        const mainTextDiv = document.getElementById('main-text');
        const playerInput = document.getElementById('player-input');
        const sendButton = document.getElementById('send-button');
        const inputArea = document.getElementById('input-area'); // Référence à la zone de saisie

        const gameOverActionArea = document.getElementById('game-over-action-area'); // Nouveau conteneur pour le bouton de fin de partie
        const endGameButton = document.getElementById('end-game-button'); // Nouveau bouton "Terminer la partie"

        const customModal = document.getElementById('custom-modal');
        const modalTitle = document.getElementById('modal-title');
        const modalMessage = document.getElementById('modal-message');
        const leaderboardsDisplay = document.getElementById('leaderboards-display');
        const modalCloseButton = document.getElementById('modal-close-button');

        let chatHistory = []; // Historique pour l'API Gemini (texte)

        /**
         * Affiche ou masque l'overlay de chargement.
         * @param {boolean} show - True pour afficher, false pour masquer.
         */
        function showLoading(show) {
            if (show) {
                loadingOverlay.style.display = 'flex';
                // Fond noir complètement opaque
                loadingOverlay.style.backgroundColor = '#000';
                // Utilise requestAnimationFrame pour s'assurer que display est appliqué avant la transition
                requestAnimationFrame(() => {
                    loadingOverlay.classList.add('active');
                });
                // Message "Chargement..." unifié pour tous les états
                loadingMessage.textContent = "Chargement...";
            } else {
                loadingOverlay.classList.remove('active');
                // Écoute la fin de la transition pour masquer l'élément complètement
                loadingOverlay.addEventListener('transitionend', function handler() {
                    loadingOverlay.style.display = 'none';
                    // Assurez-vous que le fond redevient transparent après la transition si nécessaire,
                    // bien que display:none le masque complètement.
                    loadingOverlay.removeEventListener('transitionend', handler);
                }, { once: true });
            }
        }

        /**
         * Affiche une modale personnalisée.
         * @param {string} title - Titre de la modale.
         * @param {string} message - Message de la modale.
         * @param {boolean} showLeaderboards - Indique si les classements doivent être affichés.
         */
        async function showCustomModal(title, message, showLeaderboards = false) {
            modalTitle.textContent = title;
            modalMessage.textContent = message;
            if (showLeaderboards) {
                await displayLeaderboards();
                leaderboardsDisplay.style.display = 'flex';
            } else {
                leaderboardsDisplay.style.display = 'none';
            }
            customModal.style.display = 'flex';
        }

        // Fermer la modale / Recommencer le jeu
        modalCloseButton.onclick = () => {
            customModal.style.display = 'none';
            resetGame();
            showMainMenu();
        };

        // Gérer le clic sur le bouton "Terminer la partie"
        endGameButton.onclick = async () => {
            await saveScore(player.name, player.score, player.mode);
            await showCustomModal("FIN DE PARTIE !", `Votre aventure dans Generativus prend fin. Vous avez atteint un score de ${player.score}.`, true);
            showLoading(false);
        };

        /**
         * Initialise Firebase et l'authentification.
         */
        async function initializeFirebase() {
            try {
                // Vérifier si une configuration Firebase valide est présente (pas la config par défaut ou manquante)
                if (!firebaseConfig.apiKey || firebaseConfig.apiKey === "YOUR_API_KEY") {
                    console.warn("Firebase configuration manquante ou par défaut. Les fonctionnalités Firestore et Auth ne seront pas disponibles en dehors de l'environnement Canvas.");
                    showCustomModal("Configuration Firebase", "La configuration Firebase n'est pas complète. Les classements ne seront pas sauvegardés ni affichés en dehors de l'environnement Canvas. Veuillez consulter le code pour ajouter votre configuration.");
                    authReady = true; // Permettre au jeu de continuer sans Firebase
                    userId = crypto.randomUUID(); // Utiliser un ID aléatoire comme fallback
                    if (!gameStarted) {
                        showMainMenu();
                    }
                    return;
                }

                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        userId = user.uid;
                        console.log("Firebase Authenticated. User ID:", userId);
                    } else {
                        console.log("Firebase Not Authenticated, attempting anonymous sign-in.");
                        try {
                            if (initialAuthToken) {
                                await signInWithCustomToken(auth, initialAuthToken);
                                userId = auth.currentUser.uid;
                                console.log("Signed in with custom token. User ID:", userId);
                            } else {
                                await signInAnonymously(auth);
                                userId = auth.currentUser.uid;
                                console.log("Signed in anonymously. User ID:", userId);
                            }
                        } catch (error) {
                            console.error("Firebase Auth Error:", error);
                            showCustomModal("Erreur d'authentification", "Impossible de se connecter à Firebase. Certaines fonctionnalités (classements) pourraient être limitées.");
                            userId = crypto.randomUUID(); // Fallback for userId
                            console.warn("Using a random UUID for userId as fallback:", userId);
                        }
                    }
                    authReady = true;
                    if (!gameStarted) {
                        showMainMenu(); // Afficher le menu principal une fois que l'authentification est prête
                    }
                });
            } catch (error) {
                console.error("Erreur lors de l'initialisation de Firebase:", error);
                showCustomModal("Erreur Firebase", "Impossible d'initialiser Firebase. Vérifiez la configuration. Les classements ne seront pas sauvegardés.");
                userId = crypto.randomUUID(); // Fallback for userId
                console.warn("Using a random UUID for userId as fallback:", userId);
                authReady = true; // Permettre au jeu de continuer même si Firebase a échoué
                if (!gameStarted) {
                    showMainMenu();
                }
            }
        }

        /**
         * Met à jour l'affichage des statistiques du joueur.
         */
        function updateStatsUI() {
            playerAttSpan.textContent = `ATT: ${player.att}`;
            playerHpSpan.textContent = `VIE: ${Math.max(0, player.vie)}/${player.maxVie}`;
            playerAgiSpan.textContent = `AGI: ${player.agi}`;
        }

        /**
         * Met à jour le texte principal affiché dans le jeu, avec une logique de défilement améliorée.
         * @param {string} text - Le texte à afficher.
         * @param {boolean} isPlayerMessage - Indique si le message vient du joueur.
         */
        function updateMainText(text, isPlayerMessage = false) {
            const p = document.createElement('p');
            p.innerHTML = text; // Utiliser innerHTML pour permettre les retours à la ligne
            mainTextDiv.appendChild(p);

            if (isPlayerMessage) {
                p.classList.add('player-message');
                lastPlayerMessageElement = p; // Stocke la référence au dernier message du joueur
                // Défile toujours jusqu'à la fin pour que le joueur voie sa propre saisie.
                scrollableContent.scrollTop = scrollableContent.scrollHeight;
            } else {
                // Pour les messages de l'IA, défile jusqu'au dernier input du joueur
                // ou au début si aucun input joueur n'a été fait.
                requestAnimationFrame(() => {
                    if (lastPlayerMessageElement) {
                        lastPlayerMessageElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    } else {
                        // Si c'est le tout premier texte du jeu, défile au début.
                        scrollableContent.scrollTop = 0;
                    }
                });
            }
        }


        /**
         * Met à jour l'image du jeu en appelant l'API Gemini Image.
         * @param {string} imagePrompt - Le prompt pour la génération d'image.
         */
        async function updateGameImage(imagePrompt) {
            gameImage.style.display = 'none'; // Cache l'image pour s'assurer qu'elle est couverte
            gameImage.src = ''; // Efface l'image précédente
            showLoading(true); // Utilise l'écran de chargement unifié

            const apiKey = GEMINI_IMAGE_API_KEY; // Utilise la clé API de la variable globale

            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-002:predict?key=${apiKey}`;

            try {
                const payload = {
                    instances: {
                        // Prompt amélioré pour le style (toujours gore) et le ratio 16:9 strict
                        prompt: `${imagePrompt}, pixel art 16:9, strict 16:9 aspect ratio, highly detailed pixel art, no video game art style, horrifying, terrifying, gruesome, stark black and white, grim`
                    },
                    parameters: {
                        sampleCount: 1
                    }
                };

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const result = await response.json();

                if (result.predictions && result.predictions.length > 0 && result.predictions[0].bytesBase64Encoded) {
                    const imageUrl = `data:image/png;base64,${result.predictions[0].bytesBase64Encoded}`;
                    gameImage.src = imageUrl;
                    gameImage.onload = () => {
                        gameImage.style.display = 'block'; // Révèle l'image une fois chargée
                        // Délai de 2 secondes supplémentaires avant de masquer l'overlay de chargement
                        setTimeout(() => {
                            showLoading(false);
                        }, 2000);
                    };
                    gameImage.onerror = () => {
                        console.error("Erreur de chargement de l'image. Tentative de placeholder.");
                        // En cas d'erreur de chargement de l'image, on garde l'overlay actif
                        showLoading(true); // L'overlay reste actif avec le message unifié "Chargement..."
                    };
                } else {
                    console.error("Réponse de l'API Image inattendue:", result);
                    // Si la réponse de l'API est inattendue, on garde l'overlay actif
                    showLoading(true); // L'overlay reste actif avec le message unifié "Chargement..."
                }
            } catch (error) {
                console.error("Erreur lors de la génération d'image:", error);
                // Si une erreur générale survient, on garde l'overlay actif
                showLoading(true); // L'overlay reste actif avec le message unifié "Chargement..."
            }
        }

        /**
         * Affiche le menu principal et gère la saisie initiale.
         */
        async function showMainMenu() {
            gameStarted = false;
            // Assure que la zone de saisie est visible et le bouton de fin de partie caché
            inputArea.style.display = 'flex';
            gameOverActionArea.style.display = 'none';

            mainTextDiv.innerHTML = 'Bienvenue dans Generativus! Un monde sans limite, lugubre et effrayant. Pourrez-vous vous en sortir vivant?<br>Entrez votre nom pour commencer.'; // Texte d'intro simplifié
            updateStatsUI();
            playerInput.placeholder = "Ex: Gérard"; // Placeholder simplifié
            // Afficher l'image du menu principal
            await updateGameImage("gloomy dungeon, scary, dark, title Generativus");
            sendButton.onclick = handleMainMenuInput; // Attacher le gestionnaire pour le menu
            playerInput.onkeypress = (e) => {
                if (e.key === 'Enter') handleMainMenuInput();
            };
            lastPlayerMessageElement = null; // Réinitialiser l'élément de défilement pour le menu
            scrollableContent.scrollTop = 0; // Assurez-vous que le texte d'intro est visible
        }

        /**
         * Gère la saisie du joueur dans le menu principal.
         */
        async function handleMainMenuInput() {
            const input = playerInput.value.trim();
            if (!input) return;

            updateMainText(`> ${input}`, true); // Affiche la saisie du joueur
            playerInput.value = ''; // Efface la saisie

            player.name = input; // Capture le nom directement
            startGame();
        }

        /**
         * Démarre une nouvelle partie.
         */
        async function startGame() {
            gameStarted = true;
            player.vie = player.maxVie; // Réinitialise la vie
            player.score = 0;
            gameDifficulty = 1; // DIFFICULTÉ INITIALE À 1
            updateStatsUI();
            player.mode = 'Gore'; // Force le mode à Gore
            document.body.classList.remove('friendly-mode'); // Assure que c'est toujours le mode Gore
            mainTextDiv.innerHTML = ''; // Efface le texte pour le début d'une nouvelle partie
            playerInput.placeholder = "Votre action...";
            sendButton.onclick = sendPlayerAction; // Attacher le gestionnaire pour le jeu
            playerInput.onkeypress = (e) => {
                if (e.key === 'Enter') sendPlayerAction();
            };
            lastPlayerMessageElement = null; // Réinitialiser l'élément de défilement au début du jeu

            // Assure que la zone de saisie est visible et le bouton de fin de partie caché
            inputArea.style.display = 'flex';
            gameOverActionArea.style.display = 'none';

            await generateBackstory();
        }

        /**
         * Génère la backstory du personnage via l'API Gemini Text.
         */
        async function generateBackstory() {
            showLoading(true); // Utilise l'écran de chargement unifié

            const apiKey = GEMINI_TEXT_API_KEY; // Utilise la clé API de la variable globale

            const prompt = `Génère une très brève backstory pour vous, un personnage nommé ${player.name}, qui êtes sur le point d'entrer dans un donjon appelé Generativus. Le ton doit être horrifiant et sombre. Sois très concis, juste un court paragraphe.`;

            chatHistory = [{ role: "user", parts: [{ text: prompt }] }];

            try {
                const response = await callGeminiTextAPI(chatHistory, { apiKey: apiKey });
                updateMainText(response); // C'est le premier texte généré, il se défilera au début.
                chatHistory.push({ role: "model", parts: [{ text: response }] });
                await continueGame();
            } catch (error) {
                console.error("Erreur lors de la génération de la backstory:", error);
                updateMainText("Une erreur est survenue lors de la génération de l'histoire. Veuillez réessayer. Détails: " + error.message);
                showLoading(false);
            }
        }

        /**
         * Continue le jeu en générant le prochain événement.
         */
        async function continueGame() {
            showLoading(true); // Utilise l'écran de chargement unifié

            const apiKey = GEMINI_TEXT_API_KEY; // Utilise la clé API de la variable globale

            // Mise à jour du prompt pour inclure la difficulté sous forme X/25
            const prompt = `Vous (${player.name}, ATT:${player.att}, VIE:${player.vie}/${player.maxVie}, AGI:${player.agi}) êtes dans un donjon. Votre inventaire contient : ${player.inventory.length > 0 ? player.inventory.join(', ') : 'rien'}. La difficulté actuelle du jeu est de ${gameDifficulty} sur ${MAX_DIFFICULTY}.
            Quel événement se produit ? Décrivez-le brièvement. Vous pouvez y introduire la découverte d'objets (armes, armures, nourriture). Proposez des choix (dans une texte fluide) ou attendez une action libre de votre part. Le ton est horrifiant et sombre.
            **Format de réponse attendu (JSON):**
            \`\`\`json
            {
              "narrative_text": "Texte décrivant l'événement et les options. Soyez concis et direct. Ex: 'Vous trouvez une épée rouillée au sol.'",
              "image_prompt": "Prompt pour l'image (contexte)",
              "action_required": true,
              "inventory_changes": [] // Optionnel: Si un objet est trouvé, ajoutez {"action": "add", "item": "Nom de l'objet"} ici.
            }
            \`\`\`
            `;

            chatHistory.push({ role: "user", parts: [{ text: prompt }] });

            try {
                const responseJson = await callGeminiTextAPI(chatHistory, {
                    apiKey: apiKey,
                    responseMimeType: "application/json",
                    responseSchema: {
                        type: "OBJECT",
                        properties: {
                            "narrative_text": { "type": "STRING" },
                            "image_prompt": { "type": "STRING" },
                            "action_required": { "type": "BOOLEAN" },
                            "inventory_changes": { // Ajout de inventory_changes dans le schéma
                                "type": "ARRAY",
                                "items": {
                                    "type": "OBJECT",
                                    "properties": {
                                        "action": { "type": "STRING" },
                                        "item": { "type": "STRING" }
                                    }
                                }
                            }
                        },
                        "propertyOrdering": ["narrative_text", "image_prompt", "action_required", "inventory_changes"] // Ajout de inventory_changes dans l'ordre
                    }
                });

                let parsedResponse;
                try {
                    parsedResponse = JSON.parse(responseJson);
                } catch (jsonError) {
                    console.warn("JSON.parse initial failed, attempting regex extraction:", jsonError);
                    const jsonMatch = responseJson.match(/```json\s*(\{[\s\S]*?\})\s*```/);
                    if (jsonMatch && jsonMatch[1]) {
                        try {
                            parsedResponse = JSON.parse(jsonMatch[1]);
                            console.log("JSON successfully extracted and parsed with regex.");
                        } catch (regexJsonError) {
                            console.error("JSON regex extraction and parsing failed:", regexJsonError);
                            throw new Error("Impossible d'extraire ou de parser le JSON de la réponse de l'API. Réponse brute: " + responseJson);
                        }
                    } else {
                        throw new Error("Réponse de l'API non-JSON et extraction regex échouée. Réponse brute: " + responseJson);
                    }
                }

                updateMainText(parsedResponse.narrative_text); // Le nouveau texte généré par l'IA.
                chatHistory.push({ role: "model", parts: [{ text: JSON.stringify(parsedResponse) }] });

                // Gérer l'inventaire si des objets sont trouvés lors d'un événement
                if (parsedResponse.inventory_changes && Array.isArray(parsedResponse.inventory_changes)) {
                    parsedResponse.inventory_changes.forEach(change => {
                        if (change.action === "add") {
                            player.inventory.push(change.item);
                            console.log(`Objet ajouté à l'inventaire: ${change.item}`);
                        }
                    });
                }

                if (parsedResponse.image_prompt) {
                    await updateGameImage(parsedResponse.image_prompt);
                }
                // Mise à jour du score en fonction de la difficulté
                player.score += Math.round(1 + gameDifficulty * 5); // Score augmente plus vite avec la difficulté
            } catch (error) {
                console.error("Erreur lors de la continuation du jeu:", error);
                updateMainText("Une erreur est survenue, le donjon semble instable. Veuillez réessayer. Détails: " + error.message);
            } finally {
                // showLoading(false); // Commenté car géré par updateGameImage ou les blocs d'erreur spécifiques.
            }
        }

        /**
         * Gère l'envoi de l'action du joueur à l'API Gemini Text.
         */
        async function sendPlayerAction() {
            const input = playerInput.value.trim();
            if (!input) return;

            updateMainText(`> ${input}`, true); // Ceci est un message du joueur
            playerInput.value = '';

            showLoading(true); // Utilise l'écran de chargement unifié

            const apiKey = GEMINI_TEXT_API_KEY; // Utilise la clé API de la variable globale

            // Mise à jour du prompt pour inclure la difficulté sous forme X/25
            const prompt = `Vous (${player.name}, ATT:${player.att}, VIE:${player.vie}/${player.maxVie}, AGI:${player.agi}) avez effectué l'action: "${input}". Votre inventaire contient : ${player.inventory.length > 0 ? player.inventory.join(', ') : 'rien'}. La difficulté actuelle du jeu est de ${gameDifficulty}/${MAX_DIFFICULTY}.
            Évaluez la réussite/échec de cette action en fonction du contexte précédent, du réalisme, et de la difficulté. Décrivez les conséquences (dégâts, gain de vie, obtention/perte d'objets, changement de statistiques, fuite, fin de combat, etc.). Soyez concis et direct. Le ton est horrifiant et sombre.

            **Gestion d'inventaire et de statistiques:**
            * Si le joueur demande à voir son inventaire (ex: "montre mon inventaire", "que j'ai?"), listez les objets actuels dans la 'narrative_text'. Ne modifiez pas les 'stat_changes' ou 'inventory_changes'.
            * Si le joueur utilise de la nourriture (ex: "manger une ration", "boire potion"):
                * Assurez-vous que l'objet est dans l'inventaire.
                * Ajoutez \`{"action": "remove", "item": "Nom de la nourriture"}\` à 'inventory_changes'.
                * Augmentez la VIE dans 'stat_changes'. La VIE ne peut pas dépasser ${player.maxVie}.
            * Si le joueur équipe une arme (ex: "équiper l'épée", "prendre la hache"):
                * Assurez-vous que l'objet est dans l'inventaire.
                * Ajoutez \`{"action": "remove", "item": "Nom de l'arme"}\` à 'inventory_changes'.
                * Augmentez l'ATT de 1 à 3 points dans 'stat_changes'. Les bonus de +3 ATT sont rares.
            * Si le joueur équipe une armure (ex: "mettre le plastron", "porter le casque"):
                * Assurez- Vous que l'objet est dans l'inventaire.
                * Ajoutez \`{"action": "remove", "item": "Nom de l'armure"}\` à 'inventory_changes'.
                * Augmentez UNE SEULE statistique (ATT, VIE max, ou AGI) de 1 à 3 points dans 'stat_changes'. Les bonus de +3 sont rares.
            * Si de nouveaux objets sont trouvés suite à cette action, ajoutez-les avec \`{"action": "add", "item": "Nom de l'objet"}\` dans 'inventory_changes'.
            * **TRÈS IMPORTANT:** Toute modification de statistiques ou d'inventaire DOIT se faire UNIQUEMENT via les champs 'stat_changes' et 'inventory_changes' du JSON, PAS dans le texte narratif (sauf pour l'inventaire). La vie maximum (VIE max) ne doit jamais dépasser 99.

            **Format de réponse attendu (JSON):**
            \`\`\`json
            {
              "narrative_text": "Texte décrivant les conséquences de l'action. Ex: 'Vous mangez la ration et vous sentez revigoré.' ou 'Vous équipez l'épée, son tranchant sinistre vous rend plus fort.'",
              "image_prompt": "Prompt pour l'image (contexte)",
              "stat_changes": { "att": 0, "vie": 0, "maxVie": 0, "agi": 0 }, // Ajoutez ici les changements de stats (ex: {"vie": 5} pour la nourriture, ou {"att": 2} pour une arme)
              "inventory_changes": [], // Ajoutez ici les modifications d'inventaire (add/remove)
              "game_over": false,
              "next_event_ready": false // True si l'IA a terminé sa réponse pour cet événement et attend le prochain
            }
            \`\`\`
            `;

            chatHistory.push({ role: "user", parts: [{ text: prompt }] });

            try {
                const responseJson = await callGeminiTextAPI(chatHistory, {
                    apiKey: apiKey,
                    responseMimeType: "application/json",
                    responseSchema: {
                        type: "OBJECT",
                        properties: {
                            "narrative_text": { "type": "STRING" },
                            "image_prompt": { "type": "STRING" },
                            "stat_changes": {
                                "type": "OBJECT",
                                "properties": {
                                    "att": { "type": "NUMBER" },
                                    "vie": { "type": "NUMBER" },
                                    "maxVie": { "type": "NUMBER" },
                                    "agi": { "type": "NUMBER" }
                                }
                            },
                            "inventory_changes": {
                                "type": "ARRAY",
                                "items": {
                                    "type": "OBJECT",
                                    "properties": {
                                        "action": { "type": "STRING" },
                                        "item": { "type": "STRING" }
                                    }
                                }
                            },
                            "game_over": { "type": "BOOLEAN" },
                            "next_event_ready": { "type": "BOOLEAN" }
                        },
                        "propertyOrdering": ["narrative_text", "image_prompt", "stat_changes", "inventory_changes", "game_over", "next_event_ready"]
                    }
                });

                let parsedResponse;
                try {
                    parsedResponse = JSON.parse(responseJson);
                } catch (jsonError) {
                    console.warn("JSON.parse initial failed, attempting regex extraction:", jsonError);
                    const jsonMatch = responseJson.match(/```json\s*(\{[\s\S]*?\})\s*```/);
                    if (jsonMatch && jsonMatch[1]) {
                        try {
                            parsedResponse = JSON.parse(jsonMatch[1]);
                            console.log("JSON successfully extracted and parsed with regex.");
                        } catch (regexJsonError) {
                            console.error("JSON regex extraction and parsing failed:", regexJsonError);
                            throw new Error("Impossible d'extraire ou de parser le JSON de la réponse de l'API. Réponse brute: " + responseJson);
                        }
                    } else {
                        throw new Error("Réponse de l'API non-JSON et extraction regex échouée. Réponse brute: " + responseJson);
                    }
                }

                updateMainText(parsedResponse.narrative_text); // C'est un message de l'IA.
                chatHistory.push({ role: "model", parts: [{ text: JSON.stringify(parsedResponse) }] });

                // Appliquer les changements de stats joueur
                if (parsedResponse.stat_changes) {
                    player.att += parsedResponse.stat_changes.att || 0;
                    player.vie += parsedResponse.stat_changes.vie || 0;
                    player.maxVie += parsedResponse.stat_changes.maxVie || 0;
                    player.agi += parsedResponse.stat_changes.agi || 0;

                    // Clamp VIE à maxVie et maxVie à 99
                    player.vie = Math.min(player.vie, player.maxVie);
                    player.maxVie = Math.min(player.maxVie, 99);
                    player.vie = Math.max(0, player.vie);

                    updateStatsUI();
                }

                // Gérer l'inventaire (pour la trace locale, l'IA est la source de vérité)
                if (parsedResponse.inventory_changes && Array.isArray(parsedResponse.inventory_changes)) {
                    parsedResponse.inventory_changes.forEach(change => {
                        if (change.action === "add") {
                            player.inventory.push(change.item);
                            console.log(`Objet ajouté à l'inventaire: ${change.item}`);
                        } else if (change.action === "remove") {
                            const index = player.inventory.indexOf(change.item);
                            if (index > -1) {
                                player.inventory.splice(index, 1);
                                console.log(`Objet retiré de l'inventaire: ${change.item}`);
                            }
                        }
                    });
                }

                // Augmenter la difficulté si l'événement progresse
                // DIFFICULTÉ AUGMENTE DE 1 ET EST AFFICHÉE SUR 25
                if (parsedResponse.next_event_ready && gameDifficulty < MAX_DIFFICULTY) {
                    gameDifficulty = Math.min(MAX_DIFFICULTY, gameDifficulty + 1);
                }

                if (parsedResponse.image_prompt) {
                    await updateGameImage(parsedResponse.image_prompt);
                }

                if (parsedResponse.game_over || player.vie <= 0) {
                    player.vie = 0;
                    updateStatsUI();
                    await gameOver(); // Appelle la fonction gameOver modifiée
                } else if (parsedResponse.next_event_ready) {
                    player.score++; // Le score est mis à jour dans `continueGame` maintenant, pas ici
                    await continueGame();
                }
            } catch (error) {
                console.error("Erreur lors du traitement de l'action du joueur:", error);
                updateMainText("Une erreur est survenue lors de l'analyse de votre action. Le jeu est bloqué, veuillez actualiser la page. Détails: " + error.message);
            } finally {
                // showLoading(false); // Commenté car géré par updateGameImage ou les blocs d'erreur spécifiques.
            }
        }

        /**
         * Appelle l'API Gemini Text.
         * @param {Array} history - L'historique des messages pour l'API.
         * @param {Object} options - Options pour la configuration de génération et la clé API.
         * @param {string} options.apiKey - La clé API à utiliser.
         * @param {Object} options.responseMimeType - Type MIME pour la réponse structurée (optionnel).
         * @param {Object} options.responseSchema - Schéma pour la réponse structurée (optionnel).
         * @returns {Promise<string>} La réponse textuelle ou JSON de l'IA.
         */
        async function callGeminiTextAPI(history, options = {}) {
            const apiKey = options.apiKey || ""; // Utilise la clé fournie ou une chaîne vide par défaut
            const payload = { contents: history };
            if (options.responseMimeType) {
                payload.generationConfig = {
                    responseMimeType: options.responseMimeType,
                    responseSchema: options.responseSchema
                };
            }
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            const result = await response.json();

            if (result.candidates && result.candidates.length > 0 &&
                result.candidates[0].content && result.candidates[0].content.parts &&
                result.candidates[0].content.parts.length > 0) {
                return result.candidates[0].content.parts[0].text;
            } else {
                console.error("Réponse de l'API Gemini inattendue:", result);
                throw new Error("Impossible d'obtenir une réponse de l'API textuelle.");
            }
        }

        /**
         * Gère la fin de partie (mort du joueur).
         */
        async function gameOver() {
            showLoading(false); // Masque le chargement s'il était actif
            // Masque la zone de saisie et affiche le bouton "Terminer la partie"
            inputArea.style.display = 'none';
            gameOverActionArea.style.display = 'block'; // Utilise 'block' pour le conteneur du bouton

            // Faites défiler le texte principal jusqu'à la fin pour que le joueur puisse tout lire
            scrollableContent.scrollTop = scrollableContent.scrollHeight;

            // Le texte final est déjà affiché dans mainTextDiv.
            // La modale ne sera affichée que lorsque le joueur cliquera sur le bouton.
        }

        /**
         * Réinitialise l'état du jeu.
         */
        function resetGame() {
            player = {
                name: '',
                att: 5,
                vie: 20,
                maxVie: 20,
                agi: 1,
                inventory: [],
                score: 0,
                mode: 'Gore' // Toujours en mode Gore
            };
            gameDifficulty = 1; // RÉINITIALISE LA DIFFICULTÉ À 1
            gameStarted = false;
            chatHistory = [];
            document.body.classList.remove('friendly-mode'); // Assure que c'est toujours le mode Gore
            mainTextDiv.innerHTML = ''; // Nettoyer le texte
            gameImage.src = ''; // Nettoyer l'image
            playerInput.value = '';
            playerInput.placeholder = "Ex: Gérard"; // Placeholder simplifié
            updateStatsUI();
            lastPlayerMessageElement = null; // Réinitialiser la référence à l'élément du message du joueur

            // S'assurer que la zone de saisie est visible et le bouton de fin de partie caché lors du reset
            inputArea.style.display = 'flex';
            gameOverActionArea.style.display = 'none';
        }

        /**
         * Enregistre le score du joueur dans Firestore si c'est un top 10.
         * @param {string} name - Nom du joueur.
         * @param {number} score - Score du joueur.
         * @param {string} mode - Mode de jeu ('Gore').
         */
        async function saveScore(name, score, mode) {
            if (!authReady || !db || !userId) {
                console.warn("Firestore non prêt, score non enregistré.");
                return;
            }
            try {
                // Toujours enregistrer en mode 'gore'
                const leaderboardDocRef = doc(db, `artifacts/${appId}/public/data/leaderboards`, 'gore');
                const leaderboardSnap = await getDoc(leaderboardDocRef);

                let scores = [];
                if (leaderboardSnap.exists()) {
                    scores = leaderboardSnap.data().topScores || [];
                }

                scores.push({ name: name, score: score, timestamp: Date.now(), userId: userId });

                // Trier et garder seulement les 10 meilleurs scores
                scores.sort((a, b) => b.score - a.score);
                scores = scores.slice(0, 10);

                await setDoc(leaderboardDocRef, { topScores: scores });
                console.log("Score enregistré avec succès !");
            } catch (error) {
                console.error("Erreur lors de l'enregistrement du score:", error);
                showCustomModal("Erreur de sauvegarde", "Impossible d'enregistrer votre score dans le classement.");
            }
        }

        /**
         * Affiche les classements depuis Firestore (seulement le mode Gore).
         */
        async function displayLeaderboards() {
            if (!authReady || !db || !userId) {
                console.warn("Firestore non prêt, impossible d'afficher les classements.");
                leaderboardsDisplay.innerHTML = '<p>Classements non disponibles.</p>';
                return;
            }

            leaderboardsDisplay.innerHTML = ''; // Nettoyer l'affichage précédent
            showLoading(true); // Utilise l'écran de chargement unifié

            // Toujours charger le classement Gore
            const mode = 'gore';
            try {
                const leaderboardDocRef = doc(db, `artifacts/${appId}/public/data/leaderboards`, mode);
                const leaderboardSnap = await getDoc(leaderboardDocRef);

                let scores = [];
                if (leaderboardSnap.exists()) {
                    scores = leaderboardSnap.data().topScores || [];
                }

                const section = document.createElement('div');
                section.classList.add('leaderboard-section');
                // Modification du titre du classement
                section.innerHTML = `<h3>Classement</h3><ol></ol>`;
                const ol = section.querySelector('ol');

                if (scores.length === 0) {
                    ol.innerHTML = '<li>Aucun score enregistré.</li>';
                } else {
                    scores.forEach((s, index) => {
                        const li = document.createElement('li');
                        li.innerHTML = `<span>${index + 1}. ${s.name}</span> <span class="score-value">${s.score}</span>`;
                        ol.appendChild(li);
                    });
                }
                leaderboardsDisplay.appendChild(section);

            } catch (error) {
                console.error(`Erreur lors du chargement du classement ${mode}:`, error);
                const section = document.createElement('div');
                section.classList.add('leaderboard-section');
                // Modification du titre du classement en cas d'erreur
                section.innerHTML = `<h3>Classement</h3><p>Erreur de chargement.</p>`;
                leaderboardsDisplay.appendChild(section);
            }
            showLoading(false);
        }

        // Initialisation à l'ouverture de la page
        window.onload = initializeFirebase;
    </script>
</body>
</html>
